/*
 * generated by Xtext 2.21.0
 */
package org.palladiosimulator.somox.docker.compose.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.palladiosimulator.somox.docker.compose.composeFile.Build;
import org.palladiosimulator.somox.docker.compose.composeFile.BuildLongSyntax;
import org.palladiosimulator.somox.docker.compose.composeFile.ComposeFilePackage;
import org.palladiosimulator.somox.docker.compose.composeFile.Config;
import org.palladiosimulator.somox.docker.compose.composeFile.Configs;
import org.palladiosimulator.somox.docker.compose.composeFile.CredentialSpec;
import org.palladiosimulator.somox.docker.compose.composeFile.Deploy;
import org.palladiosimulator.somox.docker.compose.composeFile.DeployConfigsLongSyntax;
import org.palladiosimulator.somox.docker.compose.composeFile.DockerCompose;
import org.palladiosimulator.somox.docker.compose.composeFile.Healthcheck;
import org.palladiosimulator.somox.docker.compose.composeFile.Ipam;
import org.palladiosimulator.somox.docker.compose.composeFile.List;
import org.palladiosimulator.somox.docker.compose.composeFile.Logging;
import org.palladiosimulator.somox.docker.compose.composeFile.Mapping;
import org.palladiosimulator.somox.docker.compose.composeFile.MappingWithPrefixAndColon;
import org.palladiosimulator.somox.docker.compose.composeFile.MappingWithPrefixAndEqual;
import org.palladiosimulator.somox.docker.compose.composeFile.MappingWithoutPrefixAndColon;
import org.palladiosimulator.somox.docker.compose.composeFile.MappingWithoutPrefixAndEqual;
import org.palladiosimulator.somox.docker.compose.composeFile.Networks;
import org.palladiosimulator.somox.docker.compose.composeFile.Placement;
import org.palladiosimulator.somox.docker.compose.composeFile.PortLongSyntax;
import org.palladiosimulator.somox.docker.compose.composeFile.Ports;
import org.palladiosimulator.somox.docker.compose.composeFile.RestartPolicy;
import org.palladiosimulator.somox.docker.compose.composeFile.Secrets;
import org.palladiosimulator.somox.docker.compose.composeFile.Service;
import org.palladiosimulator.somox.docker.compose.composeFile.ServiceSecrets;
import org.palladiosimulator.somox.docker.compose.composeFile.ServiceSecretsLongSyntax;
import org.palladiosimulator.somox.docker.compose.composeFile.ServiceVolumeLongSyntax;
import org.palladiosimulator.somox.docker.compose.composeFile.ServiceVolumes;
import org.palladiosimulator.somox.docker.compose.composeFile.Ulimits;
import org.palladiosimulator.somox.docker.compose.composeFile.Volumes;
import org.palladiosimulator.somox.docker.compose.services.ComposeFileGrammarAccess;

@SuppressWarnings("all")
public class ComposeFileSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private ComposeFileGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == ComposeFilePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case ComposeFilePackage.BUILD:
				sequence_Build(context, (Build) semanticObject); 
				return; 
			case ComposeFilePackage.BUILD_LONG_SYNTAX:
				sequence_BuildLongSyntax(context, (BuildLongSyntax) semanticObject); 
				return; 
			case ComposeFilePackage.CONFIG:
				sequence_Config(context, (Config) semanticObject); 
				return; 
			case ComposeFilePackage.CONFIGS:
				if (rule == grammarAccess.getConfigsRule()) {
					sequence_Configs(context, (Configs) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getDeployConfigsRule()) {
					sequence_DeployConfigs(context, (Configs) semanticObject); 
					return; 
				}
				else break;
			case ComposeFilePackage.CREDENTIAL_SPEC:
				sequence_CredentialSpec(context, (CredentialSpec) semanticObject); 
				return; 
			case ComposeFilePackage.DEPLOY:
				sequence_Deploy(context, (Deploy) semanticObject); 
				return; 
			case ComposeFilePackage.DEPLOY_CONFIGS_LONG_SYNTAX:
				sequence_DeployConfigsLongSyntax(context, (DeployConfigsLongSyntax) semanticObject); 
				return; 
			case ComposeFilePackage.DOCKER_COMPOSE:
				sequence_DockerCompose(context, (DockerCompose) semanticObject); 
				return; 
			case ComposeFilePackage.HEALTHCHECK:
				sequence_Healthcheck(context, (Healthcheck) semanticObject); 
				return; 
			case ComposeFilePackage.IPAM:
				sequence_Ipam(context, (Ipam) semanticObject); 
				return; 
			case ComposeFilePackage.LIST:
				if (rule == grammarAccess.getListOrMappingRule()
						|| rule == grammarAccess.getListRule()) {
					sequence_List(context, (List) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getValueOrListRule()) {
					sequence_List_ValueOrList(context, (List) semanticObject); 
					return; 
				}
				else break;
			case ComposeFilePackage.LOGGING:
				sequence_Logging(context, (Logging) semanticObject); 
				return; 
			case ComposeFilePackage.MAPPING:
				sequence_Mapping(context, (Mapping) semanticObject); 
				return; 
			case ComposeFilePackage.MAPPING_WITH_PREFIX_AND_COLON:
				sequence_MappingWithPrefixAndColon(context, (MappingWithPrefixAndColon) semanticObject); 
				return; 
			case ComposeFilePackage.MAPPING_WITH_PREFIX_AND_EQUAL:
				sequence_MappingWithPrefixAndEqual(context, (MappingWithPrefixAndEqual) semanticObject); 
				return; 
			case ComposeFilePackage.MAPPING_WITHOUT_PREFIX_AND_COLON:
				sequence_MappingWithoutPrefixAndColon(context, (MappingWithoutPrefixAndColon) semanticObject); 
				return; 
			case ComposeFilePackage.MAPPING_WITHOUT_PREFIX_AND_EQUAL:
				sequence_MappingWithoutPrefixAndEqual(context, (MappingWithoutPrefixAndEqual) semanticObject); 
				return; 
			case ComposeFilePackage.NETWORKS:
				sequence_Networks(context, (Networks) semanticObject); 
				return; 
			case ComposeFilePackage.PLACEMENT:
				sequence_Placement(context, (Placement) semanticObject); 
				return; 
			case ComposeFilePackage.PORT_LONG_SYNTAX:
				sequence_PortLongSyntax(context, (PortLongSyntax) semanticObject); 
				return; 
			case ComposeFilePackage.PORTS:
				sequence_Ports(context, (Ports) semanticObject); 
				return; 
			case ComposeFilePackage.RESTART_POLICY:
				sequence_RestartPolicy(context, (RestartPolicy) semanticObject); 
				return; 
			case ComposeFilePackage.SECRETS:
				sequence_Secrets(context, (Secrets) semanticObject); 
				return; 
			case ComposeFilePackage.SERVICE:
				sequence_Service(context, (Service) semanticObject); 
				return; 
			case ComposeFilePackage.SERVICE_SECRETS:
				sequence_ServiceSecrets(context, (ServiceSecrets) semanticObject); 
				return; 
			case ComposeFilePackage.SERVICE_SECRETS_LONG_SYNTAX:
				sequence_ServiceSecretsLongSyntax(context, (ServiceSecretsLongSyntax) semanticObject); 
				return; 
			case ComposeFilePackage.SERVICE_VOLUME_LONG_SYNTAX:
				sequence_ServiceVolumeLongSyntax(context, (ServiceVolumeLongSyntax) semanticObject); 
				return; 
			case ComposeFilePackage.SERVICE_VOLUMES:
				sequence_ServiceVolumes(context, (ServiceVolumes) semanticObject); 
				return; 
			case ComposeFilePackage.ULIMITS:
				sequence_Ulimits(context, (Ulimits) semanticObject); 
				return; 
			case ComposeFilePackage.VOLUMES:
				sequence_Volumes(context, (Volumes) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Build returns BuildLongSyntax
	 *     BuildLongSyntax returns BuildLongSyntax
	 *
	 * Constraint:
	 *     (
	 *         context=Value | 
	 *         dockerfile=Value | 
	 *         args=ListOrMapping | 
	 *         labels=ListOrMapping | 
	 *         cache_from=ListOrMapping | 
	 *         network=Value | 
	 *         target=Value | 
	 *         shm_size=Value
	 *     )+
	 */
	protected void sequence_BuildLongSyntax(ISerializationContext context, BuildLongSyntax semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Build returns Build
	 *
	 * Constraint:
	 *     build=Value
	 */
	protected void sequence_Build(ISerializationContext context, Build semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.BUILD__BUILD) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.BUILD__BUILD));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getBuildAccess().getBuildValueParserRuleCall_0_1_0(), semanticObject.getBuild());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeployConfigs returns Config
	 *     Config returns Config
	 *
	 * Constraint:
	 *     (
	 *         parallelism=Value | 
	 *         delay=Value | 
	 *         failure_action=Value | 
	 *         monitor=Value | 
	 *         max_failure_ratio=Value | 
	 *         order=Value
	 *     )+
	 */
	protected void sequence_Config(ISerializationContext context, Config semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Configs returns Configs
	 *
	 * Constraint:
	 *     (name=ID (file=Value | external=Value | customName=Value)+)
	 */
	protected void sequence_Configs(ISerializationContext context, Configs semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     CredentialSpec returns CredentialSpec
	 *
	 * Constraint:
	 *     (file=Value | registry=Value)
	 */
	protected void sequence_CredentialSpec(ISerializationContext context, CredentialSpec semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DeployConfigs returns DeployConfigsLongSyntax
	 *     DeployConfigsLongSyntax returns DeployConfigsLongSyntax
	 *
	 * Constraint:
	 *     (source=Value target=Value uid=Value gid=Value mode=Value)
	 */
	protected void sequence_DeployConfigsLongSyntax(ISerializationContext context, DeployConfigsLongSyntax semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__TARGET));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__UID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__UID));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__GID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__GID));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.DEPLOY_CONFIGS_LONG_SYNTAX__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeployConfigsLongSyntaxAccess().getSourceValueParserRuleCall_1_3_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getDeployConfigsLongSyntaxAccess().getTargetValueParserRuleCall_2_2_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getDeployConfigsLongSyntaxAccess().getUidValueParserRuleCall_3_2_0(), semanticObject.getUid());
		feeder.accept(grammarAccess.getDeployConfigsLongSyntaxAccess().getGidValueParserRuleCall_4_2_0(), semanticObject.getGid());
		feeder.accept(grammarAccess.getDeployConfigsLongSyntaxAccess().getModeValueParserRuleCall_5_2_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     DeployConfigs returns Configs
	 *
	 * Constraint:
	 *     list=ListOrMapping
	 */
	protected void sequence_DeployConfigs(ISerializationContext context, Configs semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.CONFIGS__LIST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.CONFIGS__LIST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getDeployConfigsAccess().getListListOrMappingParserRuleCall_0_1_0(), semanticObject.getList());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Deploy returns Deploy
	 *
	 * Constraint:
	 *     (
	 *         endpoint_mode=Value | 
	 *         labels=Mapping | 
	 *         mode=Value | 
	 *         placement=Placement | 
	 *         replicas=Value | 
	 *         resources=Value | 
	 *         restart_policy=RestartPolicy | 
	 *         rollback_config=DeployConfigs | 
	 *         update_config=DeployConfigs
	 *     )+
	 */
	protected void sequence_Deploy(ISerializationContext context, Deploy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     DockerCompose returns DockerCompose
	 *
	 * Constraint:
	 *     (
	 *         version=STRING 
	 *         services+=Service* 
	 *         volumes+=Volumes* 
	 *         networks+=Networks* 
	 *         configs+=Configs* 
	 *         secrets+=Secrets*
	 *     )
	 */
	protected void sequence_DockerCompose(ISerializationContext context, DockerCompose semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Healthcheck returns Healthcheck
	 *
	 * Constraint:
	 *     (
	 *         disable=Value | 
	 *         interval=Value | 
	 *         retries=Value | 
	 *         test=ValueOrList | 
	 *         timeout=Value | 
	 *         start_period=Value
	 *     )+
	 */
	protected void sequence_Healthcheck(ISerializationContext context, Healthcheck semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ipam returns Ipam
	 *
	 * Constraint:
	 *     (driver=Value config=ListOrMapping)
	 */
	protected void sequence_Ipam(ISerializationContext context, Ipam semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.IPAM__DRIVER) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.IPAM__DRIVER));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.IPAM__CONFIG) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.IPAM__CONFIG));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getIpamAccess().getDriverValueParserRuleCall_2_2_0(), semanticObject.getDriver());
		feeder.accept(grammarAccess.getIpamAccess().getConfigListOrMappingParserRuleCall_3_2_0(), semanticObject.getConfig());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ListOrMapping returns List
	 *     List returns List
	 *
	 * Constraint:
	 *     list+=Value+
	 */
	protected void sequence_List(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ValueOrList returns List
	 *
	 * Constraint:
	 *     (list+=Value | list+=Value+)
	 */
	protected void sequence_List_ValueOrList(ISerializationContext context, List semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Logging returns Logging
	 *
	 * Constraint:
	 *     (driver=Value options=Mapping)+
	 */
	protected void sequence_Logging(ISerializationContext context, Logging semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingWithPrefixAndColon returns MappingWithPrefixAndColon
	 *
	 * Constraint:
	 *     (name=Value value=Value?)
	 */
	protected void sequence_MappingWithPrefixAndColon(ISerializationContext context, MappingWithPrefixAndColon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingWithPrefixAndEqual returns MappingWithPrefixAndEqual
	 *
	 * Constraint:
	 *     (name=Value value=Value?)
	 */
	protected void sequence_MappingWithPrefixAndEqual(ISerializationContext context, MappingWithPrefixAndEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingWithoutPrefixAndColon returns MappingWithoutPrefixAndColon
	 *
	 * Constraint:
	 *     (name=Value value=Value?)
	 */
	protected void sequence_MappingWithoutPrefixAndColon(ISerializationContext context, MappingWithoutPrefixAndColon semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     MappingWithoutPrefixAndEqual returns MappingWithoutPrefixAndEqual
	 *
	 * Constraint:
	 *     (name=Value value=Value?)
	 */
	protected void sequence_MappingWithoutPrefixAndEqual(ISerializationContext context, MappingWithoutPrefixAndEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ListOrMapping returns Mapping
	 *     Mapping returns Mapping
	 *
	 * Constraint:
	 *     (map+=MappingWithPrefixAndColon+ | map+=MappingWithoutPrefixAndColon+ | map+=MappingWithPrefixAndEqual+ | map+=MappingWithoutPrefixAndEqual+)
	 */
	protected void sequence_Mapping(ISerializationContext context, Mapping semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Networks returns Networks
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             driver=Value | 
	 *             driver_opts=Mapping | 
	 *             attachable=Value | 
	 *             enable_ipv6=Value | 
	 *             ipam=Ipam | 
	 *             internal=Value | 
	 *             labels=ListOrMapping | 
	 *             external=Value | 
	 *             customName=Value
	 *         )*
	 *     )
	 */
	protected void sequence_Networks(ISerializationContext context, Networks semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Placement returns Placement
	 *
	 * Constraint:
	 *     (constraints=ValueOrList | preferences=ListOrMapping)+
	 */
	protected void sequence_Placement(ISerializationContext context, Placement semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ports returns PortLongSyntax
	 *     PortLongSyntax returns PortLongSyntax
	 *
	 * Constraint:
	 *     (target=Value published=Value protocol=Value mode=Value)
	 */
	protected void sequence_PortLongSyntax(ISerializationContext context, PortLongSyntax semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__TARGET));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__PUBLISHED) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__PUBLISHED));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__PROTOCOL) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__PROTOCOL));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.PORT_LONG_SYNTAX__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortLongSyntaxAccess().getTargetValueParserRuleCall_1_3_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getPortLongSyntaxAccess().getPublishedValueParserRuleCall_2_2_0(), semanticObject.getPublished());
		feeder.accept(grammarAccess.getPortLongSyntaxAccess().getProtocolValueParserRuleCall_3_2_0(), semanticObject.getProtocol());
		feeder.accept(grammarAccess.getPortLongSyntaxAccess().getModeValueParserRuleCall_4_2_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Ports returns Ports
	 *
	 * Constraint:
	 *     ports=List
	 */
	protected void sequence_Ports(ISerializationContext context, Ports semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.PORTS__PORTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.PORTS__PORTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getPortsAccess().getPortsListParserRuleCall_0_1_0(), semanticObject.getPorts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     RestartPolicy returns RestartPolicy
	 *
	 * Constraint:
	 *     (condition=Value | delay=Value | max_attempts=Value | window=Value)+
	 */
	protected void sequence_RestartPolicy(ISerializationContext context, RestartPolicy semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Secrets returns Secrets
	 *
	 * Constraint:
	 *     (name=ID (file=Value | external=Value | customName=Value)+)
	 */
	protected void sequence_Secrets(ISerializationContext context, Secrets semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     ServiceSecrets returns ServiceSecretsLongSyntax
	 *     ServiceSecretsLongSyntax returns ServiceSecretsLongSyntax
	 *
	 * Constraint:
	 *     (source=Value target=Value uid=Value gid=Value mode=Value)
	 */
	protected void sequence_ServiceSecretsLongSyntax(ISerializationContext context, ServiceSecretsLongSyntax semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__TARGET));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__UID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__UID));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__GID) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__GID));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__MODE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS_LONG_SYNTAX__MODE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceSecretsLongSyntaxAccess().getSourceValueParserRuleCall_1_3_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getServiceSecretsLongSyntaxAccess().getTargetValueParserRuleCall_2_2_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getServiceSecretsLongSyntaxAccess().getUidValueParserRuleCall_3_2_0(), semanticObject.getUid());
		feeder.accept(grammarAccess.getServiceSecretsLongSyntaxAccess().getGidValueParserRuleCall_4_2_0(), semanticObject.getGid());
		feeder.accept(grammarAccess.getServiceSecretsLongSyntaxAccess().getModeValueParserRuleCall_5_2_0(), semanticObject.getMode());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ServiceSecrets returns ServiceSecrets
	 *
	 * Constraint:
	 *     secret=Value
	 */
	protected void sequence_ServiceSecrets(ISerializationContext context, ServiceSecrets semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS__SECRET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_SECRETS__SECRET));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceSecretsAccess().getSecretValueParserRuleCall_0_1_0(), semanticObject.getSecret());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ServiceVolumes returns ServiceVolumeLongSyntax
	 *     ServiceVolumeLongSyntax returns ServiceVolumeLongSyntax
	 *
	 * Constraint:
	 *     (
	 *         type=Value 
	 *         source=Value 
	 *         target=Value 
	 *         read_only=Value 
	 *         consistency=Value 
	 *         bindPropagation=Value 
	 *         volumeNocopy=Value 
	 *         tmpfsSize=Value
	 *     )
	 */
	protected void sequence_ServiceVolumeLongSyntax(ISerializationContext context, ServiceVolumeLongSyntax semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__TYPE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__TYPE));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__SOURCE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__SOURCE));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__TARGET) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__TARGET));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__READ_ONLY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__READ_ONLY));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__CONSISTENCY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__CONSISTENCY));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__BIND_PROPAGATION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__BIND_PROPAGATION));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__VOLUME_NOCOPY) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__VOLUME_NOCOPY));
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__TMPFS_SIZE) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUME_LONG_SYNTAX__TMPFS_SIZE));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getTypeValueParserRuleCall_2_0(), semanticObject.getType());
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getSourceValueParserRuleCall_3_2_0(), semanticObject.getSource());
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getTargetValueParserRuleCall_4_2_0(), semanticObject.getTarget());
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getRead_onlyValueParserRuleCall_5_2_0(), semanticObject.getRead_only());
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getConsistencyValueParserRuleCall_6_2_0(), semanticObject.getConsistency());
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getBindPropagationValueParserRuleCall_7_2_3_0(), semanticObject.getBindPropagation());
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getVolumeNocopyValueParserRuleCall_8_2_3_0(), semanticObject.getVolumeNocopy());
		feeder.accept(grammarAccess.getServiceVolumeLongSyntaxAccess().getTmpfsSizeValueParserRuleCall_9_2_3_0(), semanticObject.getTmpfsSize());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     ServiceVolumes returns ServiceVolumes
	 *
	 * Constraint:
	 *     volumes=Value
	 */
	protected void sequence_ServiceVolumes(ISerializationContext context, ServiceVolumes semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUMES__VOLUMES) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, ComposeFilePackage.Literals.SERVICE_VOLUMES__VOLUMES));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getServiceVolumesAccess().getVolumesValueParserRuleCall_2_0_0(), semanticObject.getVolumes());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Service returns Service
	 *
	 * Constraint:
	 *     (
	 *         name=ID 
	 *         (
	 *             build=Build | 
	 *             cap_add=List | 
	 *             cap_drop=List | 
	 *             cgroup_parent=Value | 
	 *             command=Value | 
	 *             command=Value | 
	 *             container_name=Value | 
	 *             credential_spec=CredentialSpec | 
	 *             depends_on=List | 
	 *             deploy=Deploy | 
	 *             devices=List | 
	 *             dns=List | 
	 *             dns=List | 
	 *             domainname=Value | 
	 *             entrypoint=ValueOrList | 
	 *             env_file=ValueOrList | 
	 *             environment=Mapping | 
	 *             expose=List | 
	 *             external_links=List | 
	 *             external_links=ListOrMapping | 
	 *             healthcheck=Healthcheck | 
	 *             hostname=Value | 
	 *             image=Value | 
	 *             init=Value | 
	 *             ipc=Value | 
	 *             isolation=Value | 
	 *             labels=ListOrMapping | 
	 *             links=ListOrMapping | 
	 *             logging=Logging | 
	 *             mac_address=Value | 
	 *             network_mode=Value | 
	 *             networks=List | 
	 *             pid=Value | 
	 *             ports=Ports | 
	 *             privileged=Value | 
	 *             read_only=Value | 
	 *             restart=Value | 
	 *             secrets=ServiceSecrets | 
	 *             security_opt=List | 
	 *             shm_size=Value | 
	 *             stdin_open=Value | 
	 *             stop_grace_period=Value | 
	 *             stop_signal=Value | 
	 *             sysctls=ListOrMapping | 
	 *             sysctls=ValueOrList | 
	 *             tty=Value | 
	 *             ulimits=Ulimits | 
	 *             user=Value | 
	 *             userns_mode=Value | 
	 *             volumes=ServiceVolumes | 
	 *             working_dir=Value
	 *         )+
	 *     )
	 */
	protected void sequence_Service(ISerializationContext context, Service semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Ulimits returns Ulimits
	 *
	 * Constraint:
	 *     ((name=ID value=Value) | (name=ID soft=Value hard=Value))
	 */
	protected void sequence_Ulimits(ISerializationContext context, Ulimits semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Volumes returns Volumes
	 *
	 * Constraint:
	 *     (name=ID (driver=Value | driver_opts=Mapping | external=Value | labels=ListOrMapping | customName=Value)*)
	 */
	protected void sequence_Volumes(ISerializationContext context, Volumes semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
}
