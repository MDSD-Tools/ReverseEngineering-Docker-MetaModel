/*
 * generated by Xtext 2.21.0
 */
package org.palladiosimulator.somox.docker.serializer;

import com.google.inject.Inject;
import java.util.Set;
import org.eclipse.emf.ecore.EObject;
import org.eclipse.emf.ecore.EPackage;
import org.eclipse.xtext.Action;
import org.eclipse.xtext.Parameter;
import org.eclipse.xtext.ParserRule;
import org.eclipse.xtext.serializer.ISerializationContext;
import org.eclipse.xtext.serializer.acceptor.SequenceFeeder;
import org.eclipse.xtext.serializer.sequencer.AbstractDelegatingSemanticSequencer;
import org.eclipse.xtext.serializer.sequencer.ITransientValueService.ValueTransient;
import org.palladiosimulator.somox.docker.dockerFile.AddDestination;
import org.palladiosimulator.somox.docker.dockerFile.Cmd;
import org.palladiosimulator.somox.docker.dockerFile.DockerFilePackage;
import org.palladiosimulator.somox.docker.dockerFile.Dockerfile;
import org.palladiosimulator.somox.docker.dockerFile.EnvWithEqual;
import org.palladiosimulator.somox.docker.dockerFile.EnvWithSpace;
import org.palladiosimulator.somox.docker.dockerFile.Expose;
import org.palladiosimulator.somox.docker.dockerFile.From;
import org.palladiosimulator.somox.docker.dockerFile.JSON_ARRAY;
import org.palladiosimulator.somox.docker.dockerFile.Maintainer;
import org.palladiosimulator.somox.docker.dockerFile.Onbuild;
import org.palladiosimulator.somox.docker.dockerFile.RunWithNoShell;
import org.palladiosimulator.somox.docker.dockerFile.RunWithShell;
import org.palladiosimulator.somox.docker.dockerFile.User;
import org.palladiosimulator.somox.docker.dockerFile.Volume;
import org.palladiosimulator.somox.docker.dockerFile.Workdir;
import org.palladiosimulator.somox.docker.services.DockerFileGrammarAccess;

@SuppressWarnings("all")
public class DockerFileSemanticSequencer extends AbstractDelegatingSemanticSequencer {

	@Inject
	private DockerFileGrammarAccess grammarAccess;
	
	@Override
	public void sequence(ISerializationContext context, EObject semanticObject) {
		EPackage epackage = semanticObject.eClass().getEPackage();
		ParserRule rule = context.getParserRule();
		Action action = context.getAssignedAction();
		Set<Parameter> parameters = context.getEnabledBooleanParameters();
		if (epackage == DockerFilePackage.eINSTANCE)
			switch (semanticObject.eClass().getClassifierID()) {
			case DockerFilePackage.ADD_DESTINATION:
				if (rule == grammarAccess.getAddRule()) {
					sequence_Add(context, (AddDestination) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getInstructionRule()) {
					sequence_Add_Copy(context, (AddDestination) semanticObject); 
					return; 
				}
				else if (rule == grammarAccess.getCopyRule()) {
					sequence_Copy(context, (AddDestination) semanticObject); 
					return; 
				}
				else break;
			case DockerFilePackage.CMD:
				sequence_Cmd_Entrypoint(context, (Cmd) semanticObject); 
				return; 
			case DockerFilePackage.DOCKERFILE:
				sequence_Dockerfile(context, (Dockerfile) semanticObject); 
				return; 
			case DockerFilePackage.ENV_WITH_EQUAL:
				sequence_EnvWithEqual(context, (EnvWithEqual) semanticObject); 
				return; 
			case DockerFilePackage.ENV_WITH_SPACE:
				sequence_EnvWithSpace(context, (EnvWithSpace) semanticObject); 
				return; 
			case DockerFilePackage.EXPOSE:
				sequence_Expose(context, (Expose) semanticObject); 
				return; 
			case DockerFilePackage.FROM:
				sequence_From(context, (From) semanticObject); 
				return; 
			case DockerFilePackage.JSON_ARRAY:
				sequence_JSON_ARRAY(context, (JSON_ARRAY) semanticObject); 
				return; 
			case DockerFilePackage.MAINTAINER:
				sequence_Maintainer(context, (Maintainer) semanticObject); 
				return; 
			case DockerFilePackage.ONBUILD:
				sequence_Onbuild(context, (Onbuild) semanticObject); 
				return; 
			case DockerFilePackage.RUN_WITH_NO_SHELL:
				sequence_RunWithNoShell(context, (RunWithNoShell) semanticObject); 
				return; 
			case DockerFilePackage.RUN_WITH_SHELL:
				sequence_RunWithShell(context, (RunWithShell) semanticObject); 
				return; 
			case DockerFilePackage.USER:
				sequence_User(context, (User) semanticObject); 
				return; 
			case DockerFilePackage.VOLUME:
				sequence_Volume(context, (Volume) semanticObject); 
				return; 
			case DockerFilePackage.WORKDIR:
				sequence_Workdir(context, (Workdir) semanticObject); 
				return; 
			}
		if (errorAcceptor != null)
			errorAcceptor.accept(diagnosticProvider.createInvalidContextOrTypeDiagnostic(semanticObject, context));
	}
	
	/**
	 * Contexts:
	 *     Add returns AddDestination
	 *
	 * Constraint:
	 *     (source_left=AddSource dest=ONE_SPACE_AND_WHATEVER)
	 */
	protected void sequence_Add(ISerializationContext context, AddDestination semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__SOURCE_LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__SOURCE_LEFT));
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__DEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getAddAccess().getSource_leftAddSourceParserRuleCall_1_0(), semanticObject.getSource_left());
		feeder.accept(grammarAccess.getAddAccess().getDestONE_SPACE_AND_WHATEVERTerminalRuleCall_2_0(), semanticObject.getDest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns AddDestination
	 *
	 * Constraint:
	 *     ((source_left=AddSource dest=ONE_SPACE_AND_WHATEVER) | (source_left=AddSource dest=ONE_SPACE_AND_WHATEVER))
	 */
	protected void sequence_Add_Copy(ISerializationContext context, AddDestination semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Cmd
	 *     Cmd returns Cmd
	 *     Entrypoint returns Cmd
	 *
	 * Constraint:
	 *     {Cmd}
	 */
	protected void sequence_Cmd_Entrypoint(ISerializationContext context, Cmd semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Copy returns AddDestination
	 *
	 * Constraint:
	 *     (source_left=AddSource dest=ONE_SPACE_AND_WHATEVER)
	 */
	protected void sequence_Copy(ISerializationContext context, AddDestination semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__SOURCE_LEFT) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__SOURCE_LEFT));
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__DEST) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.ADD_DESTINATION__DEST));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getCopyAccess().getSource_leftAddSourceParserRuleCall_1_1_0_0(), semanticObject.getSource_left());
		feeder.accept(grammarAccess.getCopyAccess().getDestONE_SPACE_AND_WHATEVERTerminalRuleCall_1_1_1_0(), semanticObject.getDest());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Dockerfile returns Dockerfile
	 *
	 * Constraint:
	 *     instructions+=Instruction+
	 */
	protected void sequence_Dockerfile(ISerializationContext context, Dockerfile semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns EnvWithEqual
	 *     Env returns EnvWithEqual
	 *     EnvWithEqual returns EnvWithEqual
	 *
	 * Constraint:
	 *     (key+=ID value+=ENV_VALUE_WITH_EQUAL)+
	 */
	protected void sequence_EnvWithEqual(ISerializationContext context, EnvWithEqual semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns EnvWithSpace
	 *     Env returns EnvWithSpace
	 *     EnvWithSpace returns EnvWithSpace
	 *
	 * Constraint:
	 *     (key+=ID value+=ONE_SPACE_AND_WHATEVER)
	 */
	protected void sequence_EnvWithSpace(ISerializationContext context, EnvWithSpace semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Expose
	 *     Expose returns Expose
	 *
	 * Constraint:
	 *     ports=ONE_SPACE_AND_WHATEVER
	 */
	protected void sequence_Expose(ISerializationContext context, Expose semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.EXPOSE__PORTS) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.EXPOSE__PORTS));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getExposeAccess().getPortsONE_SPACE_AND_WHATEVERTerminalRuleCall_1_0(), semanticObject.getPorts());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns From
	 *     From returns From
	 *
	 * Constraint:
	 *     (name=VALID_IMAGE_NAME tag=VALID_IMAGE_TAG?)
	 */
	protected void sequence_From(ISerializationContext context, From semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns JSON_ARRAY
	 *     Cmd returns JSON_ARRAY
	 *     Copy returns JSON_ARRAY
	 *     Entrypoint returns JSON_ARRAY
	 *     Volume returns JSON_ARRAY
	 *     JSON_ARRAY returns JSON_ARRAY
	 *
	 * Constraint:
	 *     (head=STRING tail+=STRING_PREFIXED_WITH_COMMA*)
	 */
	protected void sequence_JSON_ARRAY(ISerializationContext context, JSON_ARRAY semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Maintainer
	 *     Maintainer returns Maintainer
	 *
	 * Constraint:
	 *     name=ONE_SPACE_AND_WHATEVER
	 */
	protected void sequence_Maintainer(ISerializationContext context, Maintainer semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.MAINTAINER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.MAINTAINER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getMaintainerAccess().getNameONE_SPACE_AND_WHATEVERTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Onbuild
	 *     Onbuild returns Onbuild
	 *
	 * Constraint:
	 *     instruction=Instruction
	 */
	protected void sequence_Onbuild(ISerializationContext context, Onbuild semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.ONBUILD__INSTRUCTION) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.ONBUILD__INSTRUCTION));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getOnbuildAccess().getInstructionInstructionParserRuleCall_1_0(), semanticObject.getInstruction());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RunWithNoShell
	 *     Run returns RunWithNoShell
	 *     RunWithNoShell returns RunWithNoShell
	 *
	 * Constraint:
	 *     (executable=STRING params+=STRING_PREFIXED_WITH_COMMA*)
	 */
	protected void sequence_RunWithNoShell(ISerializationContext context, RunWithNoShell semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns RunWithShell
	 *     Run returns RunWithShell
	 *     RunWithShell returns RunWithShell
	 *
	 * Constraint:
	 *     command=ONE_SPACE_AND_WHATEVER
	 */
	protected void sequence_RunWithShell(ISerializationContext context, RunWithShell semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.RUN_WITH_SHELL__COMMAND) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.RUN_WITH_SHELL__COMMAND));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getRunWithShellAccess().getCommandONE_SPACE_AND_WHATEVERTerminalRuleCall_0(), semanticObject.getCommand());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns User
	 *     User returns User
	 *
	 * Constraint:
	 *     name=ID
	 */
	protected void sequence_User(ISerializationContext context, User semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.USER__NAME) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.USER__NAME));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getUserAccess().getNameIDTerminalRuleCall_1_0(), semanticObject.getName());
		feeder.finish();
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Volume
	 *     Volume returns Volume
	 *
	 * Constraint:
	 *     {Volume}
	 */
	protected void sequence_Volume(ISerializationContext context, Volume semanticObject) {
		genericSequencer.createSequence(context, semanticObject);
	}
	
	
	/**
	 * Contexts:
	 *     Instruction returns Workdir
	 *     Workdir returns Workdir
	 *
	 * Constraint:
	 *     path=ONE_SPACE_AND_WHATEVER
	 */
	protected void sequence_Workdir(ISerializationContext context, Workdir semanticObject) {
		if (errorAcceptor != null) {
			if (transientValues.isValueTransient(semanticObject, DockerFilePackage.Literals.WORKDIR__PATH) == ValueTransient.YES)
				errorAcceptor.accept(diagnosticProvider.createFeatureValueMissing(semanticObject, DockerFilePackage.Literals.WORKDIR__PATH));
		}
		SequenceFeeder feeder = createSequencerFeeder(context, semanticObject);
		feeder.accept(grammarAccess.getWorkdirAccess().getPathONE_SPACE_AND_WHATEVERTerminalRuleCall_1_0(), semanticObject.getPath());
		feeder.finish();
	}
	
	
}
